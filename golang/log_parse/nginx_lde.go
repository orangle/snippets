
/*
 This file was autogenerated via
 -----------------------------------------
 ldetool generate nginx.lde --package main
 -----------------------------------------
 do not touch it with bare hands!
*/

package main

import (
	"bytes"
	"fmt"
	"strconv"
	"unsafe"
)

var minusSpaceMinusSpaceLsbrck = []byte("- - [")
var space = []byte(" ")

// Nginx ...
type Nginx struct {
	rest         []byte
	IP           []byte
	Time         []byte
	Cost         uint32
	Request      []byte
	Status       int64
	ByteSend     int64
	BodyByteSend int64
	Referer      []byte
	Cookie       []byte
	UserAgent    []byte
	Xfor         []byte
	ConnID       []byte
	Hit          []byte
	ServerIp     []byte
}

// Extract ...
func (p *Nginx) Extract(line []byte) (bool, error) {
	p.rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as IP(string)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		p.IP = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `"- - ["` and pass it
	if bytes.HasPrefix(p.rest, minusSpaceMinusSpaceLsbrck) {
		p.rest = p.rest[len(minusSpaceMinusSpaceLsbrck):]
	} else {
		return false, nil
	}

	// Take until ']' as Time(string)
	pos = bytes.IndexByte(p.rest, ']')
	if pos >= 0 {
		p.Time = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `" "` and pass it
	if bytes.HasPrefix(p.rest, space) {
		p.rest = p.rest[len(space):]
	} else {
		return false, nil
	}

	// Take until " " as Cost(uint32)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Cost = uint32(tmpUint)

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as Request(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Request = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `" "` and pass it
	if bytes.HasPrefix(p.rest, space) {
		p.rest = p.rest[len(space):]
	} else {
		return false, nil
	}

	// Take until " " as Status(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.Status = int64(tmpInt)

	// Take until " " as ByteSend(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.ByteSend = int64(tmpInt)

	// Take until " " as BodyByteSend(int64)
	pos = bytes.Index(p.rest, space)
	if pos >= 0 {
		tmp = p.rest[:pos]
		p.rest = p.rest[pos+len(space):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("Cannot parse `%s`: %s", string(tmp), err)
	}
	p.BodyByteSend = int64(tmpInt)

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as Referer(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Referer = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `" "` and pass it
	if bytes.HasPrefix(p.rest, space) {
		p.rest = p.rest[len(space):]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as Cookie(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Cookie = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.rest) >= 1 && p.rest[0] == ' ' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as UserAgent(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.UserAgent = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.rest) >= 1 && p.rest[0] == ' ' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as Xfor(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Xfor = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with ' ' and pass it
	if len(p.rest) >= 1 && p.rest[0] == ' ' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until ' ' as ConnID(string)
	pos = bytes.IndexByte(p.rest, ' ')
	if pos >= 0 {
		p.ConnID = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with '"' and pass it
	if len(p.rest) >= 1 && p.rest[0] == '"' {
		p.rest = p.rest[1:]
	} else {
		return false, nil
	}

	// Take until '"' as Hit(string)
	pos = bytes.IndexByte(p.rest, '"')
	if pos >= 0 {
		p.Hit = p.rest[:pos]
		p.rest = p.rest[pos+1:]
	} else {
		return false, nil
	}

	// Checks if the rest starts with `" "` and pass it
	if bytes.HasPrefix(p.rest, space) {
		p.rest = p.rest[len(space):]
	} else {
		return false, nil
	}

	// Take the rest as ServerIp(string)
	p.ServerIp = p.rest
	p.rest = p.rest[len(p.rest):]
	return true, nil
}
